{
	RegisteredRule(rule=onlyAuthorizedCanTransferSpec, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=unauthorazedTransferSpec, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=slotConsistencySpec, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=transferValueToNewTokenSpec, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=transferValuePreservesTotal, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=mintOnTransferIncreasesSupply, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=derivedTokenInheritsSlot, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=transferToZeroAddressFails, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=approveZeroAddressFails, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=concurrentApprovalChange, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=nonNegativeBalances, ruleType=Root(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=null, isCounted=true): true,
	RegisteredRule(rule=Induction base: After the constructor, ruleType=InductionBase(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=nonNegativeBalances, isCounted=true): true,
	RegisteredRule(rule=Induction step: after external (non-view) methods, ruleType=InductionSteps(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=nonNegativeBalances, isCounted=true): true,
	RegisteredRule(rule=Using general requirements, ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=nonNegativeBalances, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=transferToZeroAddressFails, range=ERC3525.spec:107:1, params=[uint256 fromTokenId], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:108:5, cvlType=env, id=e, scope=(Spec file -> Rule transferToZeroAddressFails)), address zeroAddr = 0x0, uint256 value = ERC3525.balanceOf(e,fromTokenId), Apply(range=ERC3525.spec:112:5, exp=ERC3525.transferFrom(e,fromTokenId,zeroAddr,value) could_revert, scope=(Spec file -> Rule transferToZeroAddressFails)), Assert(range=ERC3525.spec:114:5, exp=lastReverted, description="TransferÃªncia para address(0) deve reverter", scope=(Spec file -> Rule transferToZeroAddressFails), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule transferToZeroAddressFails), methodParamFilters=MethodParamFilters(range=ERC3525.spec:107:1, scope=(Spec file -> Rule transferToZeroAddressFails), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=transferToZeroAddressFails, isCounted=true): true,
	RegisteredRule(rule=setApprovalForAll(address,bool), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=safeTransferFrom(address,address,uint256,bytes), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=approve(address,uint256), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=transferFrom(uint256,address,uint256), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=approve(uint256,address,uint256), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=transferFrom(uint256,uint256,uint256), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=transferFrom(address,address,uint256), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=safeTransferFrom(address,address,uint256), ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), parentCVLDeclarationId=Using general requirements, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=slotConsistencySpec, range=ERC3525.spec:45:1, params=[uint256 tokenId], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:46:5, cvlType=env, id=e, scope=(Spec file -> Rule slotConsistencySpec)), uint256 slotAntes = ERC3525.slotOf(e,tokenId), uint256 slotDepois = ERC3525.slotOf(e,tokenId), Assert(range=ERC3525.spec:51:5, exp=slotAntes == slotDepois, description=slotAntes == slotDepois, scope=(Spec file -> Rule slotConsistencySpec), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule slotConsistencySpec), methodParamFilters=MethodParamFilters(range=ERC3525.spec:45:1, scope=(Spec file -> Rule slotConsistencySpec), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=slotConsistencySpec, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=approveZeroAddressFails, range=ERC3525.spec:118:1, params=[uint256 tokenId], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:119:5, cvlType=env, id=e, scope=(Spec file -> Rule approveZeroAddressFails)), address zeroAddr = 0x0, uint256 value = 100, Apply(range=ERC3525.spec:123:5, exp=ERC3525.approve(e,tokenId,zeroAddr,value) could_revert, scope=(Spec file -> Rule approveZeroAddressFails)), Assert(range=ERC3525.spec:125:5, exp=lastReverted, description="AprovaÃ§Ã£o para address(0) deve reverter", scope=(Spec file -> Rule approveZeroAddressFails), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule approveZeroAddressFails), methodParamFilters=MethodParamFilters(range=ERC3525.spec:118:1, scope=(Spec file -> Rule approveZeroAddressFails), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=approveZeroAddressFails, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=mintOnTransferIncreasesSupply, range=ERC3525.spec:91:1, params=[uint256 fromId, address to, uint256 value], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:92:5, cvlType=env, id=e, scope=(Spec file -> Rule mintOnTransferIncreasesSupply)), uint256 supplyBefore = ERC3525.totalSupply(e), Apply(range=ERC3525.spec:94:5, exp=ERC3525.transferFrom(e,fromId,to,value), scope=(Spec file -> Rule mintOnTransferIncreasesSupply)), Assert(range=ERC3525.spec:95:5, exp=ERC3525.totalSupply(e) == supplyBefore + 1, description=totalSupply(e) == supplyBefore + 1, scope=(Spec file -> Rule mintOnTransferIncreasesSupply), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule mintOnTransferIncreasesSupply), methodParamFilters=MethodParamFilters(range=ERC3525.spec:91:1, scope=(Spec file -> Rule mintOnTransferIncreasesSupply), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=mintOnTransferIncreasesSupply, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=concurrentApprovalChange, range=ERC3525.spec:129:1, params=[], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:130:5, cvlType=env, id=e, scope=(Spec file -> Rule concurrentApprovalChange)), uint256 tokenId = 1, address operator = 0x555555, Apply(range=ERC3525.spec:135:5, exp=ERC3525.approve(e,tokenId,operator,100), scope=(Spec file -> Rule concurrentApprovalChange)), Apply(range=ERC3525.spec:136:5, exp=ERC3525.approve(e,tokenId,operator,0), scope=(Spec file -> Rule concurrentApprovalChange)), Assert(range=ERC3525.spec:138:5, exp=ERC3525.allowance(e,tokenId,operator) == 0, description="AprovaÃ§Ã£o concorrente pode deixar allowance inconsistente", scope=(Spec file -> Rule concurrentApprovalChange), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule concurrentApprovalChange), methodParamFilters=MethodParamFilters(range=ERC3525.spec:129:1, scope=(Spec file -> Rule concurrentApprovalChange), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=concurrentApprovalChange, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=derivedTokenInheritsSlot, range=ERC3525.spec:99:1, params=[uint256 fromId, address to, uint256 value], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:100:5, cvlType=env, id=e, scope=(Spec file -> Rule derivedTokenInheritsSlot)), uint256 originalSlot = ERC3525.slotOf(e,fromId), uint256 newId = ERC3525.transferFrom(e,fromId,to,value), Assert(range=ERC3525.spec:103:5, exp=ERC3525.slotOf(e,newId) == originalSlot, description=slotOf(e, newId) == originalSlot, scope=(Spec file -> Rule derivedTokenInheritsSlot), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule derivedTokenInheritsSlot), methodParamFilters=MethodParamFilters(range=ERC3525.spec:99:1, scope=(Spec file -> Rule derivedTokenInheritsSlot), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=derivedTokenInheritsSlot, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-setApprovalForAll(address,bool), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:232:5, instMethodSignatures=[setApprovalForAll(address,bool)]), isSatisfyRule=false)), parentCVLDeclarationId=setApprovalForAll(address,bool), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-approve(address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:148:5, instMethodSignatures=[approve(address,uint256)]), isSatisfyRule=false)), parentCVLDeclarationId=approve(address,uint256), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=unauthorazedTransferSpec, range=ERC3525.spec:25:1, params=[address from, address to, uint256 tokenId], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:26:5, cvlType=env, id=e, scope=(Spec file -> Rule unauthorazedTransferSpec)), Assume(range=ERC3525.spec:29:5, exp=ERC3525.ownerOf(e,tokenId) != e.msg.sender, scope=(Spec file -> Rule unauthorazedTransferSpec), invariantPreCond=false), Assume(range=ERC3525.spec:30:5, exp=ERC3525.getApproved(e,tokenId) != e.msg.sender, scope=(Spec file -> Rule unauthorazedTransferSpec), invariantPreCond=false), Assume(range=ERC3525.spec:31:5, exp=!(ERC3525.isApprovedForAll(e,ERC3525.ownerOf(e,tokenId),e.msg.sender)), scope=(Spec file -> Rule unauthorazedTransferSpec), invariantPreCond=false), uint256 balanceBefore = ERC3525.balanceOf(e,tokenId), address ownerBefore = ERC3525.ownerOf(e,tokenId), Apply(range=ERC3525.spec:36:5, exp=ERC3525.transferFrom(e,from,to,tokenId), scope=(Spec file -> Rule unauthorazedTransferSpec)), Assert(range=ERC3525.spec:39:5, exp=ERC3525.balanceOf(e,tokenId) == balanceBefore, description=balanceOf(e, tokenId) == balanceBefore, scope=(Spec file -> Rule unauthorazedTransferSpec), invariantPostCond=false), Assert(range=ERC3525.spec:40:5, exp=ERC3525.ownerOf(e,tokenId) == ownerBefore, description=ownerOf(e, tokenId) == ownerBefore, scope=(Spec file -> Rule unauthorazedTransferSpec), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule unauthorazedTransferSpec), methodParamFilters=MethodParamFilters(range=ERC3525.spec:25:1, scope=(Spec file -> Rule unauthorazedTransferSpec), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=unauthorazedTransferSpec, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=transferValuePreservesTotal, range=ERC3525.spec:79:1, params=[uint256 fromId, uint256 toId, uint256 value], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:80:5, cvlType=env, id=e, scope=(Spec file -> Rule transferValuePreservesTotal)), Assume(range=ERC3525.spec:81:5, exp=ERC3525.slotOf(e,fromId) == ERC3525.slotOf(e,toId), scope=(Spec file -> Rule transferValuePreservesTotal), invariantPreCond=false), Assume(range=ERC3525.spec:82:5, exp=ERC3525.balanceOf(e,fromId) >= value, scope=(Spec file -> Rule transferValuePreservesTotal), invariantPreCond=false), mathint totalBefore = ERC3525.balanceOf(e,fromId) + ERC3525.balanceOf(e,toId), Apply(range=ERC3525.spec:86:5, exp=ERC3525.transferFrom(e,fromId,toId,value), scope=(Spec file -> Rule transferValuePreservesTotal)), Assert(range=ERC3525.spec:87:5, exp=ERC3525.balanceOf(e,fromId) + ERC3525.balanceOf(e,toId) == totalBefore, description=balanceOf(e, fromId) + balanceOf(e, toId) == totalBefore, scope=(Spec file -> Rule transferValuePreservesTotal), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule transferValuePreservesTotal), methodParamFilters=MethodParamFilters(range=ERC3525.spec:79:1, scope=(Spec file -> Rule transferValuePreservesTotal), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=transferValuePreservesTotal, isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-approve(uint256,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:148:5, instMethodSignatures=[approve(uint256,address,uint256)]), isSatisfyRule=false)), parentCVLDeclarationId=approve(uint256,address,uint256), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-safeTransferFrom(address,address,uint256,bytes), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:207:5, instMethodSignatures=[safeTransferFrom(address,address,uint256,bytes)]), isSatisfyRule=false)), parentCVLDeclarationId=safeTransferFrom(address,address,uint256,bytes), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-transferFrom(uint256,uint256,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:162:5, instMethodSignatures=[transferFrom(uint256,uint256,uint256)]), isSatisfyRule=false)), parentCVLDeclarationId=transferFrom(uint256,uint256,uint256), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-transferFrom(address,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:162:5, instMethodSignatures=[transferFrom(address,address,uint256)]), isSatisfyRule=false)), parentCVLDeclarationId=transferFrom(address,address,uint256), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-transferFrom(uint256,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:162:5, instMethodSignatures=[transferFrom(uint256,address,uint256)]), isSatisfyRule=false)), parentCVLDeclarationId=transferFrom(uint256,address,uint256), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-setApprovalForAll(address,bool), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:232:5, instMethodSignatures=[setApprovalForAll(address,bool)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=setApprovalForAll(address,bool), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-safeTransferFrom(address,address,uint256,bytes), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:207:5, instMethodSignatures=[safeTransferFrom(address,address,uint256,bytes)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=safeTransferFrom(address,address,uint256,bytes), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-approve(address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:148:5, instMethodSignatures=[approve(address,uint256)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=approve(address,uint256), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-transferFrom(uint256,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:162:5, instMethodSignatures=[transferFrom(uint256,address,uint256)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=transferFrom(uint256,address,uint256), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-approve(uint256,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:148:5, instMethodSignatures=[approve(uint256,address,uint256)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=approve(uint256,address,uint256), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-transferFrom(uint256,uint256,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:162:5, instMethodSignatures=[transferFrom(uint256,uint256,uint256)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=transferFrom(uint256,uint256,uint256), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-transferFrom(address,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:162:5, instMethodSignatures=[transferFrom(address,address,uint256)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=transferFrom(address,address,uint256), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-safeTransferFrom(address,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:207:5, instMethodSignatures=[safeTransferFrom(address,address,uint256)]), isSatisfyRule=false)), parentCVLDeclarationId=safeTransferFrom(address,address,uint256), isCounted=true): true,
	RegisteredRule(rule=invariant_not_trivial_postcondition, ruleType=TrivialInvariantCheck(originalRule=CVLSingleRule(ruleIdentifier=nonNegativeBalances-Using general requirements-safeTransferFrom(address,address,uint256), range=ERC3525.spec:1:1, params=[env e, uint256 tokenId, method certoraInvF, calldataarg invariantCalldata, env invariantEnv], description=Invariant breached, goodDescription=Invariant preserved, block=[Start(range=ERC3525.spec:1:1, content=assume weak invariant in pre-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Assume(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPreCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=1), Start(range=ERC3525.spec:1:1, content=check effects of step taken by one of the functions, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Apply(range=ERC3525.spec:1:1, exp=certoraInvF(invariantEnv,invariantCalldata), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements)), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=2), Start(range=ERC3525.spec:1:1, content=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3), Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true), End(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), id=3)], ruleType=GenericPreservedInductionStep(originalInv=CVLInvariant(range=ERC3525.spec:1:1, id=nonNegativeBalances, ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, params=[env e, uint256 tokenId], exp=balanceOf(e,tokenId) >= 0, methodParamFilters=MethodParamFilters(range=[internally generated], scope=(Spec file -> Invariant nonNegativeBalances), methodParamToFilter={}), proof=CVLInvariantProof(preserved=[]), scope=(Spec file -> Invariant nonNegativeBalances), needsVerification=true, uniqueRuleIdentifier=nonNegativeBalances, invariantType=spec.cvlast.WeakInvariantType@8c5f0c10)), scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamFilters=MethodParamFilters(range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), methodParamToFilter={certoraInvF=MethodParamFilter(methodParam=certoraInvF, filterExp=true && certoraInvF.selector != 0x6fdde03 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe8a3d485 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9c3dd87 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x9cc7f708 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x840f7113 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x6352211e || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x1ffc9a7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x70a08231 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe345e0bc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x95d89b41 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xe985e9c5 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x2f745c59 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0xc87b56dd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x18160ddd || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x4f6ccce7 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x3e7e8669 || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x81812fc || certoraInvF.contract != 274184521717934524641157099916833587223 && certoraInvF.selector != 0x263f3e7e || certoraInvF.contract != 274184521717934524641157099916833587223, range=ERC3525.spec:1:1, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements))}), ruleGenerationMeta=WithMethodInstantiations(sanity=PRE_SANITY_CHECK, range=ERC3525.sol:207:5, instMethodSignatures=[safeTransferFrom(address,address,uint256)]), isSatisfyRule=false), assertCVLCmd=Assert(range=ERC3525.spec:1:1, exp=ERC3525.balanceOf(e,tokenId) >= 0, description=assert weak invariant in post-state, scope=(Spec file -> Invariant nonNegativeBalances -> Rule Using general requirements), invariantPostCond=true)), parentCVLDeclarationId=safeTransferFrom(address,address,uint256), isCounted=true): true,
	RegisteredRule(rule=rule_not_vacuous, ruleType=VacuityCheck(originalRule=CVLSingleRule(ruleIdentifier=transferValueToNewTokenSpec, range=ERC3525.spec:55:1, params=[uint256 fromTokenId, address recipient, uint256 value], description=, goodDescription=, block=[Declaration(range=ERC3525.spec:56:5, cvlType=env, id=e, scope=(Spec file -> Rule transferValueToNewTokenSpec)), Assume(range=ERC3525.spec:59:5, exp=ERC3525.ownerOf(e,fromTokenId) == e.msg.sender, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPreCond=false), Assume(range=ERC3525.spec:60:5, exp=ERC3525.balanceOf(e,fromTokenId) >= value, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPreCond=false), uint256 balBefore = ERC3525.balanceOf(e,fromTokenId), uint256 slotBefore = ERC3525.slotOf(e,fromTokenId), uint256 supplyBefore = ERC3525.totalSupply(e), uint256 newId = ERC3525.transferFrom(e,fromTokenId,recipient,value), Assert(range=ERC3525.spec:71:5, exp=ERC3525.balanceOf(e,fromTokenId) == balBefore - value, description=balanceOf(e, fromTokenId) == balBefore - value, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPostCond=false), Assert(range=ERC3525.spec:72:5, exp=ERC3525.ownerOf(e,newId) == recipient, description=ownerOf(e, newId) == recipient, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPostCond=false), Assert(range=ERC3525.spec:73:5, exp=ERC3525.balanceOf(e,newId) == value, description=balanceOf(e, newId) == value, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPostCond=false), Assert(range=ERC3525.spec:74:5, exp=ERC3525.slotOf(e,newId) == slotBefore, description=slotOf(e, newId) == slotBefore, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPostCond=false), Assert(range=ERC3525.spec:75:5, exp=ERC3525.totalSupply(e) == supplyBefore + 1, description=totalSupply(e) == supplyBefore + 1, scope=(Spec file -> Rule transferValueToNewTokenSpec), invariantPostCond=false)], ruleType=spec.cvlast.SpecType$Single$FromUser$SpecFile@5436ad87, scope=(Spec file -> Rule transferValueToNewTokenSpec), methodParamFilters=MethodParamFilters(range=ERC3525.spec:55:1, scope=(Spec file -> Rule transferValueToNewTokenSpec), methodParamToFilter={}), ruleGenerationMeta=WithSanity(sanity=PRE_SANITY_CHECK), isSatisfyRule=false)), parentCVLDeclarationId=transferValueToNewTokenSpec, isCounted=true): true
}